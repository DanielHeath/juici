{"body":"## JuiCI\r\n\r\nJuiCI is a CI server that has a notion of queuing and priority.\r\n\r\nIt's designed to work well with [agent99](https://github.com/99designs/agent99) but will play nicely with most frontends to CI.\r\n\r\n## Features\r\n\r\n* callbacks are created as builds are requested\r\n* Builds are executed sequentially in a series of parallel queues.\r\n* Queues can be dynamically created\r\n* Build status visualised\r\n\r\n## Important but Miscellaneous\r\n\r\nIf you create child process in modules/plugins then you need to register your\r\ndisinterest or JuiCI will think they're builds and that would be bad\r\n\r\n## Setup\r\n\r\nJuiCI is deliberately very light on the setup front.\r\n\r\n```bash\r\n\r\nbundle install\r\nbundle exec juici\r\n```\r\n\r\nis all you need to have a working instance (provided that you have mongo installed)\r\n\r\n## Usage\r\n\r\nJuiCI chooses to be very \"Mongo\" (which is an adjective now), in that you don't\r\nneed to formally create a project. Just request a build; however this means\r\nthat on your first build you will need to send the commands to create your test\r\nenvironment)\r\n\r\nExample:\r\n\r\n```bash\r\n\r\ncurl --data-ascii @/dev/stdin <<EOF\r\npayload={\"environment\":{\r\n\"SHA1\":\"e8b179f75bbc8717c948af052353424d458af981\"},\r\n\"command\":\"[ -d .git ] || (git init .; git remote add origin git://github.com/richo/twat.git); git fetch; git checkout $SHA1; bundle install; bundle exec rake spec\"\r\nEOF\r\n```\r\n\r\nUsing a convention like `script/cibuild` as in janky/hubot etc is advisable,\r\nalthough bear in mind that the logic to checkout the repo will need to be\r\nseperate.\r\n\r\n## Priority\r\n\r\nJuiCI supports the notion of priority. Builds given without a priority will be\r\nassigned priority 1 (to allow for marking a build as less important with\r\npriority 0).\r\n\r\nIf juici recieves a new build with priority higher than any currently\r\nunfinished, it will pause whatever it's doing and build the new project. If\r\nthere is a tie for priority, a FIFO queue is assumed.\r\n\r\nJuiCI uses `SIGSTOP` and `SIGCONT` internally for job control.\r\n\r\n## Hooks\r\n\r\nYou may specify one or more callbacks when you request a build. They will be\r\ncalled with an (as yet unformalised) json body as the body if/when the build\r\nreaches that state. Alternately you may specify \"any\" as the callback state and\r\nit will be called on all state changes.\r\n\r\n## Security\r\n\r\nJuiCI poses some interesting security conecerns. First off, it will allow\r\nanyone with access to run arbitrary commands on your server. I have\r\ndeliberately not implemented any kind of security inside JuiCI, it plays nicely\r\nas a Rack application, and middlewares are much better suited to this task.\r\n\r\nIt should go without saying, but any builds started by JuiCI will inherit its\r\nenvironment. This means that if you run it in dev mode and forward your ssh\r\nagent, builds can ssh to other machines as you!\r\n\r\nWhen running in production you should take steps to ensure that the user JuiCI\r\nruns as is no more privileged than it needs to be, and sanitise its\r\nenvironment before execution.\r\n\r\n## A note on subprocesses\r\n\r\nJuiCI by default invokes everything in a subshell- indeed this is the only way\r\nto approach this if you want to execute more than one command.\r\n\r\nWhat this means to you as the user though is that unless you go to lengths to\r\nspecifically implement it, your process won't see any of the signal handling\r\nmadness. The shell(`/bin/sh`) will see everything, and if killed, your\r\nprocesses will become orphaned, but carry on.\r\n\r\n## Contact\r\n\r\nJuiCI's code lives on [Github](https://github.com/richo/juici)\r\nand the [author](mailto:richo@psych0tik.net) can be contacted on\r\n [Twitter](https://twitter.com/rich0H)\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"Prioritised CI server","google":"","name":"JuiCI"}